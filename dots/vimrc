" ****************************************
" NeoBundle
" ****************************************
filetype off
filetype plugin indent off

if has('vim_starting')
    set nocompatible
    set rtp+=~/.vim/bundle/neobundle.vim
endif


call neobundle#begin()

NeoBundle 'vim-scripts/smarty-syntax'
NeoBundle 'StanAngeloff/php.vim'
NeoBundle 'tpope/vim-surround'
NeoBundle 'thinca/vim-partedit'
NeoBundle 'Shougo/vimfiler'
NeoBundle 'Shougo/neomru.vim'
NeoBundle 'tpope/vim-fugitive'
NeoBundle 'thinca/vim-qfreplace'
NeoBundleLazy  'Shougo/unite-outline'
" NeoBundle 'kchmck/vim-coffee-script'

NeoBundle 'thinca/vim-quickrun'
if neobundle#tap('vim-quickrun') "{{{
    call neobundle#config({'autoload': {'commands': 'QuickRun'}})
    let g:quickrun_config = {
                \ 'cpp' : {
                \ 'hook/output_encode/enable' : 1,
                \ 'hook/output_encode/encoding' : 'sjis',
                \ 'type': 'c/gcc',
                \ },
                \ 'c' : {
                \ 'hook/output_encode/enable' : 1,
                \ 'hook/output_encode/encoding' : 'sjis',
                \ 'type': 'c/gcc',
                \ },
                \ 'cs' : {
                \ 'command': 'dmcs',
                \ 'exec': ['%c %o %s -out:%s:p:r.exe', 'mono %s:p:r.exe %a', 'rm -f %s:p:r.exe'],
                \ 'tempfile': '%{tempname()}.cs',
                \ },
                \ 'java' : {
                \ 'hook/output_encode/enable' : 1,
                \ 'hook/output_encode/encoding' : 'sjis',
                \ },
                \ '_' : {
                \ 'hook/time/enable' : 1,
                \ 'hook/output_encode/enable' : 1,
                \ 'hook/output_encode/encoding' : 'sjis',
				\ 'debug': 'x',
                \ },
                \ }
    " \ 'runner' : 'vimproc',
endif "}}}
NeoBundleLazy 'lilydjwg/colorizer'
if neobundle#tap('colorizer') "{{{1
    let g:colorizer_startup = 0
    call neobundle#config({
    \ 'autoload': {
    \ 'commands': ['ColorHighlight', 'ColorToggle', 'ColorClear'],
    \ }})
endif "}}}1
NeoBundle 'bronson/vim-trailing-whitespace'
if neobundle#tap('vim-trailing-whitespace') "{{{
    let g:extra_whitespace_ignored_filetypes = ['unite']
endif
"}}}
NeoBundle 'vim-scripts/Align'
if neobundle#tap('Align') "{{{
    let g:Align_xstrlen = 3 " 重いらしい
    " http://d.hatena.ne.jp/gnarl/20120104/1325668347
endif "}}}
NeoBundle 'fuenor/qfixgrep'
if neobundle#tap('qfixgrep') "{{{
    " QuickFixウィンドウでもプレビューや絞り込みを有効化
    let QFixWin_EnableMode = 1

    " QFixHowm/QFixGrepの結果表示にロケーションリストを使用する/しない
    " let QFix_UseLocationList = 1
    let g:QFixWin_QuickFixTitleReg = '\cQuickfix'
endif "}}}
NeoBundle 'Shougo/neosnippet'
NeoBundle 'Shougo/neosnippet-snippets'
if neobundle#tap('neosnippet') "{{{
    function! neobundle#tapped.hooks.on_source(bundle)
        let g:neosnippet#snippets_directory = '~/.vim/bundle/vimwork.vim/snippets'
        imap <C-Space> <PLUG>(neosnippet_expand_or_jump)
    endfunction
endif "}}}
NeoBundleLazy 'Shougo/unite.vim'
if neobundle#tap('unite.vim') "{{{
    let g:unite_enable_start_insert = 1
    nmap <leader>u [unite]
    call neobundle#config({'autoload': {'commands':[{'name': 'Unite', 'complete': 'customlist,unite#complete_source'}]}})
    nnoremap [unite]m :<c-u>Unite file_mru directory_mru
    nnoremap [unite]r :<c-u>UniteResume
endif "}}}
NeoBundle 'mattn/emmet-vim'
if neobundle#tap('emmet-vim') "{{{
    " let g:user_emmet_leader_key='<C-Z>'
    let g:user_emmet_settings = {
                \ 'variables': {
                \ 'lang' : 'ja'
                \ }
                \ }
    call neobundle#config({'autoload': {
                \ 'filetypes': ['html','css','php'],
                \ }})
    function! neobundle#tapped.hooks.on_source(bundle)
        imap <expr><TAB>
        \ emmet#isExpandable()? emmet#expandAbbrIntelligent("\<tab>")
        \ :"\<TAB>"
    endfunction
endif "}}}
NeoBundle 'joonty/vdebug'
if neobundle#tap('vdebug') "{{{
    " let g:vdebug_keymap = {
    "             \ 'run'               : '<F5>',   F8
    "             \ 'run_to_cursor'     : '<F1>',
    "             \ 'step_over'         : '<F2>',   F10
    "             \ 'step_into'         : '<F3>',   F11
    "             \ 'step_out'          : '<F4>',   s-F11
    "             \ 'close'             : '<F6>',
    "             \ 'detach'            : '<F7>',
    "             \ 'set_breakpoint'    : '<F10>',  F9
    "             \ 'get_context'       : '<F11>',  S-F12
    "             \ 'eval_under_cursor' : '<F12>',
    "             \ }
    if(1)
    let g:vdebug_keymap = {
                \ 'run'               : '<F8>',
                \ 'run_to_cursor'     : '<F1>',
                \ 'step_over'         : '<F10>',
                \ 'step_into'         : '<F11>',
                \ 'step_out'          : '<S-F11>',
                \ 'close'             : '<F6>',
                \ 'detach'            : '<F7>',
                \ 'set_breakpoint'    : '<F9>',
                \ 'get_context'       : '<S-F12>',
                \ 'eval_under_cursor' : '<F12>',
                \ }
    endif
endif
" }}}

call neobundle#end()
filetype plugin indent on
" }}}1

" ****************************************
" Map
" ****************************************
nnoremap <leader>fp<CR> :<C-u>let @+ = expand("%:p")\|echo @+<CR>|"
nnoremap <leader>ft<CR> :<C-u>let @+ = expand("%:t")\|echo @+<CR>|"
nnoremap <S-Space> za|"
nnoremap <ESC><ESC> :<C-u>noh<CR><ESC>|"
nnoremap <C-n> :<C-u>cn<CR>|"
nnoremap <C-p> :<C-u>cN<CR>|"
nnoremap <C-j> j.|"
nnoremap <C-k> n.|"
nnoremap * :<C-u>set hls<CR>:let @/ = '\<'.expand("<cword>").'\>'\|echo @/<CR>|"
nnoremap + :<C-u>AddSearch <C-r>=expand("<cword>")<CR><CR>:echo @/<CR>|"
vnoremap < <gv|"
vnoremap > >gv|"
nnoremap go yypC
nnoremap gO yyPC
" nnoremap n nzz

so $VIMRUNTIME/macros/matchit.vim

" ****************************************
" command
" ****************************************
let g:plugin_cmdex_disable = 1
cnoremap <C-X> <C-R>=<SID>GetBufferDirectory()<CR>
function! s:GetBufferDirectory()
    let dir = expand('%:p:h')
    return dir . (exists('+shellslash') && !&shellslash ? '\' : '/')
endfunction

nnoremap <C-s> 	 :<C-u>SetNum<CR>|"
command! -narg=0 SetNum call <SID>set_num()
function! s:set_num() "{{{
" --------------------
" 連番の作成
" カーソル以降の数字を、前の数字にひとつ加算したものにする ( マイナスは、考慮しない )
" --------------------
"
  " カーソル位置の取得
  let pos = getpos(".")
  let lnum = pos[1]
  let col  = pos[2] - 1

  " =====================
  " 前の行
  " =====================
  let lstr = getline(lnum-1)

  " 数字の取得
  let nums = split(lstr, '\D\+') + [1]

  " =====================
  " 現在の行
  " =====================
  let lstr  = getline(lnum)

  " ====================
  " 数字の末尾で分割
  " --------------------
  " 1 : aaa12(3)4aaaa  : () カーソル位置
  " 2 : aaa1234 , aaaa : カーソルより後ろの数字の末尾で分割
  " 3 : aaa     , aaa  : 数字の削除
  " ====================
  let col = match(lstr, '\d\D\|\d$', col) + 1

  " カーソル後に数字がある場合は処理する
  if col > 0
    " 数字の前の文字の取得
    let head = strpart(lstr, 0, col)

    " 数字の数を抽出
    let head_ncnt = len(split(head, '\D\+')) - 1

    " 文の取得
    " 変更する部分の数字は削除する
    let str = [
          \ substitute(head, '\d\+$','',''),
          \ get(nums, head_ncnt, 0) + 1,
          \ strpart(lstr, col ),
          \ ]

    " 書き込み
    call setline(lnum, join(str,''))

    " カーソル移動
    call cursor(lnum, len(str[0].str[1]))
  endif

endfunction
"}}}
"
command! -narg=* AddSearch call <SID>addSearch(<f-args>)
function! s:addSearch(...) "{{{
    if a:0 > 0
        let @/ = @/.'\|\<'.join(a:000,'\>\|\<').'\>'
    endif
endfunction
"}}}

" ****************************************
" set
" ****************************************
" set synmaxcol=1000  " 行が長いと思い
set ve=block
set nowrap
set noswapfile
set number
set fdm=marker
set tabstop=4
set shiftwidth=4
set expandtab
set list lcs=tab:`\ |

" set - lines
set backupdir=~/.vim/bak
if !isdirectory(expand(&backupdir))
    call mkdir(expand(&backupdir))
endif

if has('persistent_undo')
    set noudf
    set undodir=~/.vim/undo
    if !isdirectory(expand(&undodir))
        call mkdir(expand(&undodir))
    endif
endif

